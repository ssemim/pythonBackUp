'''
7 8
1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7
'''

# 7은 노드의 수, 8은 간선의 수

# 정점(V)과 모서리(E)
V, E = map(int, input().split())

# 정점들의 연결 정보가 입력으로 들어온다

graph = list(map(int, input().split()))

# 자르는 숫자를 간선의 개수

# 인접 리스트
# 어떤 정점 x와 연결되어 있는 정점들을 리스트로 가지고 있다.
# adjL[x] = [1,2,3] => x번 정점과 연결되어 있는 정점들은 1번 2번 3번이 있다

adjL = [[] * V + 1 for _ in range(V + 1)]

# V+1 쓰는 이유 ) 원래 파이썬 인덱스는 0부터 세는데 그래프는 1번부터 세기 때문


# i : 간선 번호
for i in range(E):
    # s 정점과 e 정점은 연결되어있다. (인접해있다)
    s, e = graph[i * 2], graph[i * 2 + 1]

    # s정점에서 e정점으로 가는 간선이 있다.
    adjL[s].append(e)
    # e정점에서 갈 수 있는 곳 중에 s 정점이 있다 (무향 그래프의 경우)
    adjL[e].append(s)

# 인접 리스트에서는 전부 돌아 볼 필요가 없음,v번 리스트에 가면 v랑 연결되어있는 정점이 나타남

# s : 탐색을 시작하는 정점 번호
# N : 정점의 개수 (마지막 정점 번호)
# nv  : 다른 정점 번호, v에서 갈 수 있는 정점 중에 하나

def DFS(s, N):
    # 깊이우선탐색 : 한 방향으로 가능한 깊게 탐색한 후에 더 이상 갈 곳이 없으면 가장 마지막에 방문한 정점으로 돌아온다
    # 한 번 탐색한 정점은 다시 탐색하지 않는다 => 탐색여부 저장하느 ㄴ배열

    visited = [0] * (N + 1)
    # x번 탐색한 적이 있다 => visited[x] = 1
    # y번 탐색한 적이 없다 => visited[y] = 0

    # 가장 마지막에 방문한 정점으로 쉽게 돌아가기 위해 스택 사용

    stack = []

    # 현재 탐색중인 정점 번호
    v = s  # s번부터 탐색 시작

    # 시작 정점 방문했다고 체크 : 1로 바꾼다.
    visited[s] = 1
    print(v, end=" ")

    while True:
        # 현재 정점 v에서 탐색
        # v에서 갈 수 있는 다른 정점 찾기
        # nv : 다른 정점 번호
        for nv in range(1, V + 1):
    # 갈 수 있다 => v에서 nv로 갈 수 있느냐를 판단
    # v와 nv가 인접해있고, nv를 이전에 방문한 적이 없다면 갈 수 있다!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    if adjM[v][nv] and not visited[nv]:
        # 같은 코드:  if ((adjM[v][nv] == 1) and (visited[nv] == 0)):
        # v에서 nv로 가는 길이 있었고, nv를 방문한 적도 없었다
        # nv로 일단 가자
        # 가기 전에 현재 위치를 스택에 저장(왔던 길 기억하자)
        stack.append[v]
        #  nv로 이동
        v = nv
        # nv를 다음에 또 오면 안되니까 방문했다고 표시
        visited[nv] = 1
        print(nv, end=" ")
        # nv로 이동했으니, 다른 갈 수 있는 정점은 보지 않아도 된다.
        breakpoint()
        break

# for - else :
else:
# 중간에 break를 한 적이 없다면 실행되는 코드
# 중간에 break가 안됐다는 건, 갈 수 있는 다른 정점을 찾지 못했다 라는 뜻 (v기준)
# 갈 곳이 없으니 돌아간다, 돌아갈 곳은 스택에 저장해놨다
# 가장 최근에 방문했던 곳으로 돌아가야하는데, 스택은 후입선출 구조라서
# 원소를 하나 꺼내면 그곳이 바로 가장 최근에 방문했던 정점이 된다.
# 꺼내전에 비어있나? 안비어있나 먼저 확인해보고
if stack:
    # 비어있지 않으면 돌아갈 곳이 있다.
    v = stack.pop()
else:
    # 더 이상 갈 수 있는 곳도 없고 돌아갈 곳도 없으면 탐색 종료
    break;
