"""
트리의 일부를 서브 트리라고 한다.
주어진 이진 트리에서 노드 N을 루트로 하는 서브 트리에 속한 노드의 개수를 알아내는 프로그램을 만드시오.
주어지는 트리는 부모와 자식 노드 번호 사이에 특별한 규칙이 없고,
부모가 없는 노드가 전체의 루트 노드가 된다.
이런 경우의 트리는 부모 노드를 인덱스로 다음과 같은 방법으로 나타낼 수 있다.
자식 노드가 0인 경우는 노드가 자식이 없는 경우이다.

"""

# 노드 N 을 루트로 하는 서브 트리에 속한 노드의 개수 알아내야해
# 1: n 대응이므로 직접 가서 카운트를 +1 하는 수 밖에 없어


T = int(input())  # 테스트 케이스 받고

for test_case in range(1, T + 1):  # 테스트 케이스 돌면서
    E, N = map(int, input().split())

    # E는 간선의 개수 N은 밑에 딸린 노드 개수
    # 트리 노드 정보 한줄로 받아옴
    tree = list(map(int, input().split()))

    # 이제 뭘하냐면 왼쪽 오른쪽으로 나눠서 넣을 배열 미리 만들어두기
    left_child = [0] * (E + 2)  # 왼쪽 자식 저장할 배열
    right_child = [0] * (E + 2)  # 오른쪽 자식 저장할 배열

    # 아무렇게나 순회해도 상관없음 차피 숫자만 세면 되서
    # 서브트리로 쪼개자 세야하니까

    cleft = [0] * (E + 2)
    cright = [0] * (E + 2)

    # 부모 노드 인덱스를 기준으로 자식을 저장할거임 (그냥 아무렇게나 해도 되서)

    for i in range(E):
        # 앞이 부모
        p = tree[i * 2]
        # 뒤가 자식
        c = tree[i * 2 + 1]
        # 왜 저렇게 쓰냐면 (부모, 자식) (부모, 자식) 일케 들어있는 꼴이라 그럼

        # p번 노드의 왼쪽 자식이 없다면
        if cleft[p] == 0:
            # c번 노드를 p번 노드의 왼쪽 자식으로
            cleft[p] = c
        else:
            # 왼쪽 자식이 있다면 오른쪽 자식으로 (이건 그냥 규칙임)
            cright[p] = c


    # 서브트리로 다 뽀갰어
    # 이제 순회하자
    # 아무렇게나 순회해도 되니까 전위 ㄱ

    # 루트 : V
    # 왼쪽 SUB : L
    # 오른쪽 SUB : R

    # 1. 전위 순회 : V - L - R

    count = 0 # 이거 왜 여깄냐면 테스트 케이스마다 초기화 시켜줘야해서
    def preorder(t):
        # t번 노드가 존재하는 노드면 순회
        # 그리고 노드 돌 때 마다 숫자 셀 변수 만들어
        global count # 뽑아내야하니까 글로벌로 선언
        if t:
            # V 노드에서 해야할 연산 코드 작성
            count += 1  # 노드 있단거 확인했으니까 카운트에 +1
            # L : t번 노드의 왼쪽을 전위순회
            preorder(cleft[t])  # 왼쪽자식 노드 있으면 출격
            # R : t번 노드의 오른쪽을 전위순회
            preorder(cright[t])

        return count


    answer = preorder(N)
    print(f'#{test_case} {answer}')
